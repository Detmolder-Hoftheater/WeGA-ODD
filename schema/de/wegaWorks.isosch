<?xml version="1.0" encoding="utf-8"?>
<schema xmlns="http://purl.oclc.org/dsdl/schematron" queryBinding="xslt2">
   <title>ISO Schematron rules</title>
   <!-- This file generated 2020-12-17T21:13:01Z by 'extract-isosch.xsl'. -->

<!-- ********************* -->
<!-- namespaces, declared: -->
<!-- ********************* -->


<!-- ********************* -->
<!-- namespaces, implicit: -->
<!-- ********************* -->
<ns prefix="esp-d2e10047" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e10079" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e10107" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e10134" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e10161" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e10250" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e10267" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e10320" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e10358" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e10396" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e10437" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e10477" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e10529" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e10580" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e10595" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e10673" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e10874" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e10927" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e10958" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e11008" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e11069" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e11264" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e11582" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e11648" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e11715" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e11750" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e11804" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e11820" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e11845" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e11867" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e11887" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e11977" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e12005" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e12046" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e12101" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e12138" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e12178" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e12240" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e12265" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e12282" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e12321" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e12345" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e12461" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e12483" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e12515" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e12559" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e12607" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e12637" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e12669" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e12696" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e12749" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e12782" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e12810" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e12838" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e12892" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e13149" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e13192" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e13212" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e13247" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e13277" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e13353" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e13438" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e13481" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e13540" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e13575" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e14506" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e14556" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e14615" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e14645" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e14662" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e14715" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e14740" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e14818" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e14833" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e14879" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e14908" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e14937" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e15016" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e15112" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e15158" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e15220" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e15409" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e15465" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e15512" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e15630" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e15664" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e15691" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e15717" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e15761" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e15786" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e15830" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e15857" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e15995" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e16109" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e16150" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e16318" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e16390" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e16480" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e16511" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e16633" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e16708" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e16789" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e16863" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e16926" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e17001" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e17071" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e17096" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e4369" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e4466" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e4481" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e4537" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e8521" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e8553" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e8578" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e8609" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e8700" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e8722" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e8753" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e8780" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e8832" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e8866" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e8888" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e8941" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e8963" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e9022" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e9051" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e9071" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e90" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e9141" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e9231" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e9259" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e9285" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e9345" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e9377" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e9407" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e9437" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e9504" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e9540" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e9562" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e9625" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e9662" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e9684" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e9706" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e9758" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e9809" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e9827" uri="http://www.music-encoding.org/ns/mei"/>
   <ns prefix="esp-d2e9996" uri="http://www.music-encoding.org/ns/mei"/>

   <!-- ************ -->
<!-- constraints: -->
<!-- ************ -->
<pattern id="isoschematron-constraint-wegaWorks-data.ARTICULATION-warn_deprecated-1">
        <rule context="@artic">
          <assert role="warning"
                 test="not(contains(., 'marc-stacc')) and not(contains(., 'ten-stacc'))">"<value-of select="."/>" contains a deprecated value.</assert>
        </rule>
        <rule context="@artic.ges">
          <assert role="warning"
                 test="not(contains(., 'marc-stacc')) and not(contains(., 'ten-stacc'))">"<value-of select="."/>" contains a deprecated value.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-data.PLACEMENT-constrain_place-2">
        <rule context="@place">
          <assert test="not((some $token in tokenize(normalize-space(.),' ') satisfies              $token =('below','above','between','within')) and count(tokenize(normalize-space(.),' ')) gt 1)">Other values not permitted when 'above', 'below', 'between' or 'within' is
            present.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-data.STAFFREL-between_requires_adjacent_staves-3">
        <rule context="mei:*[@place eq 'between']">
          <assert test="count(tokenize(normalize-space(string(@staff)), '\s+')) = 2">The @staff
            attribute must contain 2 numerically-adjacent integer values.</assert>
          <let name="tokenizedStaff"
              value="tokenize(normalize-space(string(@staff)), '\s+')"/>
          <let name="maxValue"
              value="max((number($tokenizedStaff[1]), number($tokenizedStaff[2])))"/>
          <let name="minValue"
              value="min((number($tokenizedStaff[1]), number($tokenizedStaff[2])))"/>
          <assert test="$maxValue - $minValue = 1">Staves <value-of select="$minValue"/> and
            <value-of select="$maxValue"/> are not adjacent.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-att.notationType-notationsubtype-When_notationsubtype-4">
            <rule context="mei:*[@notationsubtype]">
              <assert test="@notationtype">An element with a notationsubtype attribute must have
                a notationtype attribute.</assert>
            </rule>
          </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-att.augmentDots-dots-dots_attribute_requires_dur-5">
            <rule context="mei:*[@dots]">
              <assert test="@dur">An element with a dots attribute must also have a dur
                attribute.</assert>
            </rule>
          </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-att.classed-class-check_classURI-6">
            <rule context="@class">
              <assert test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:category/@xml:id or matches($i, '^([a-z]+://|\.{1,2}/)')">The value in @class must either correspond to the @xml:id attribute of a category
                element or be an external URL.</assert>
            </rule>
          </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-att.cleffing.log-clef_shape_requires_clef_line-7">
        <rule context="mei:*[matches(@clef.shape, '[FCG]')]">
          <assert test="@clef.line">An 'F', 'C', or 'G' clef requires that its position be
            specified.</assert>
        </rule>
        <rule context="mei:*[matches(@clef.shape, '(TAB|perc)')]">
          <assert test="@lines">A TAB or percussion clef requires that the number of lines be
            specified.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-att.clefShape-shape_requires_line-8">
        <rule context="mei:clef[matches(@shape, '[FCG]')]">
          <assert test="@line">When @shape is present, @line must also be
            specified.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-att.dataPointing-data-check_dataTarget-9">
            <rule context="@data">
              <assert role="warning" test="not(normalize-space(.) eq '')">@data attribute should
                have content.</assert>
              <assert role="warning"
                 test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*[ancestor::mei:music]/@xml:id">The value in @data should correspond to the @xml:id attribute of a descendant of
                the music element.</assert>
            </rule>
          </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-att.metadataPointing-decls-check_declsTarget-10">
            <rule context="@decls">
              <assert role="warning" test="not(normalize-space(.) eq '')">@decls attribute
                should have content.</assert>
              <assert role="warning"
                 test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*[ancestor::mei:meiHead]/@xml:id">Each value in @decls should correspond to the @xml:id attribute of an element
                within the metadata header.</assert>
              <assert test="every $i in tokenize(., '\s+') satisfies not(substring($i,2)=//mei:term/@xml:id)">No value in @decls should correspond to the @xml:id attribute of a classification
                term. Use @class for this purpose.</assert>
            </rule>
          </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-att.extent-extent-check_extent-11">
            <rule context="@extent[matches(normalize-space(.), '^\d+(\.\d+)?$')]">
              <assert role="warning" test="../@unit">The @unit attribute is
                recommended.</assert>
            </rule>
            <rule context="@extent[matches(., '\d+(\.\d+)?\s')]">
              <assert role="warning" test="../@unit">Separation into value (@extent) and unit
                (@unit) is recommended.</assert>
            </rule>
          </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-att.handIdent-hand-check_handTarget-12">
            <rule context="@hand">
              <assert role="warning" test="not(normalize-space(.) eq '')">@hand attribute should
                have content.</assert>
              <assert role="warning"
                 test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:hand/@xml:id">Each value in @hand should correspond to the @xml:id attribute of a hand
                element.</assert>
            </rule>
          </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-att.layer.log-def-check_defTarget_layer-13">
            <rule context="mei:layer/@def">
              <assert role="warning" test="not(normalize-space(.) eq '')">@def attribute should
                have content.</assert>
              <assert role="warning"
                 test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:layerDef/@xml:id">The value in @def should correspond to the @xml:id attribute of a layerDef
                element.</assert>
            </rule>
          </pattern>
   <pattern id="schematron-constraint-wegaWorks-att.linking-copyof-When_copyof_element_empty-14">
            <rule context="mei:*[@copyof]">
              <assert test="count(child::*[not(comment() or processing-instruction())]) = 0">An
                element with a copyof attribute can only have comment or processing instruction
                descendents.</assert>
            </rule>
          </pattern>
   <pattern id="schematron-constraint-wegaWorks-att.linking-copyof-check_copyofTarget-15">
            <rule context="@copyof">
              <assert role="warning" test="not(normalize-space(.) eq '')">@copyof attribute
                should have content.</assert>
              <assert role="warning"
                 test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id">The
                value in @copyof should correspond to the @xml:id attribute of an
                element.</assert>
            </rule>
          </pattern>
   <pattern id="schematron-constraint-wegaWorks-att.linking-corresp-check_correspTarget-16">
            <rule context="@corresp">
              <assert role="warning" test="not(normalize-space(.) eq '')">@corresp attribute
                should have content.</assert>
              <assert role="warning"
                 test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id">Each
                value in @corresp should correspond to the @xml:id attribute of an
                element.</assert>
            </rule>
          </pattern>
   <pattern id="schematron-constraint-wegaWorks-att.linking-follows-check_followsTarget-17">
            <rule context="@follows">
              <assert role="warning" test="not(normalize-space(.) eq '')">@follows attribute
                should have content.</assert>
              <assert role="warning"
                 test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id">Each
                value in @follows must correspond to the @xml:id attribute of an
                element.</assert>
            </rule>
          </pattern>
   <pattern id="schematron-constraint-wegaWorks-att.linking-next-check_nextTarget-18">
            <rule context="@next">
              <assert role="warning" test="not(normalize-space(.) eq '')">@next attribute should
                have content.</assert>
              <assert role="warning"
                 test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id">Each
                value in @next should correspond to the @xml:id attribute of an
                element.</assert>
            </rule>
          </pattern>
   <pattern id="schematron-constraint-wegaWorks-att.linking-precedes-check_precedesTarget-19">
            <rule context="@precedes">
              <assert role="warning" test="not(normalize-space(.) eq '')">@precedes attribute
                should have content.</assert>
              <assert role="warning"
                 test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id">Each
                value in @precedes must correspond to the @xml:id attribute of an
                element.</assert>
            </rule>
          </pattern>
   <pattern id="schematron-constraint-wegaWorks-att.linking-prev-check_prevTarget-20">
            <rule context="@prev">
              <assert role="warning" test="not(normalize-space(.) eq '')">@prev attribute should
                have content.</assert>
              <assert role="warning"
                 test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id">Each
                value in @prev should correspond to the @xml:id attribute of an
                element.</assert>
            </rule>
          </pattern>
   <pattern id="schematron-constraint-wegaWorks-att.linking-sameas-check_sameasTarget-21">
            <rule context="@sameas">
              <assert role="warning" test="not(normalize-space(.) eq '')">@sameas attribute
                should have content.</assert>
              <assert role="warning"
                 test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id">Each
                value in @sameas should correspond to the @xml:id attribute of an
                element.</assert>
            </rule>
          </pattern>
   <pattern id="schematron-constraint-wegaWorks-att.linking-synch-check_synchTarget-22">
            <rule context="@synch">
              <assert role="warning" test="not(normalize-space(.) eq '')">@synch attribute
                should have content.</assert>
              <assert role="warning"
                 test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id">Each
                value in @synch should correspond to the @xml:id attribute of an
                element.</assert>
            </rule>
          </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-att.name-nymref-check_nymrefTarget-23">
            <rule context="@nymref">
              <assert role="warning" test="not(normalize-space(.) eq '')">@nymref attribute
                should have content.</assert>
              <assert role="warning"
                 test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id">The
                value in @nymref should correspond to the @xml:id attribute of an
                element.</assert>
            </rule>
          </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-att.origin.timestamp.logical-origin.tstamp2-origin.tstamp2_requires_origin.tstamp-24">
            <rule context="mei:*[@origin.tstamp2]">
              <assert test="@origin.tstamp">When @origin.tstamp2 is used @origin.tstamp must
                also be present.</assert>
            </rule>
          </pattern>
   <pattern id="schematron-constraint-wegaWorks-att.partIdent-part-check_part_attr_all-25">
            <rule context="@part[some $i in tokenize(., '\s+') satisfies (matches($i, '^%all$'))]">
              <assert test="count(tokenize(., '\s+')) = 1">'%all' cannot be mixed with other
                values.</assert>
            </rule>
          </pattern>
   <pattern id="schematron-constraint-wegaWorks-att.partIdent-partstaff-check_partstaff_attr_all-26">
            <rule context="@partstaff[some $i in tokenize(., '\s+') satisfies (matches($i, '^%all$'))]">
              <assert test="count(tokenize(., '\s+')) = 1">'%all' cannot be mixed with other
                values.</assert>
            </rule>
          </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-att.plist-plist-check_plistTarget-27">
            <rule context="@plist">
              <assert role="warning" test="not(normalize-space(.) eq '')">@plist attribute
                should have content.</assert>
              <assert role="warning"
                 test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id">Each
                value in @plist should correspond to the @xml:id attribute of an
                element.</assert>
            </rule>
          </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-att.ranging-confidence-check_confidence-28">
            <rule context="mei:*[@confidence]">
              <assert test="@min and @max">The attributes @min and @max are required when
                @confidence is present.</assert>
            </rule>
          </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-att.responsibility-resp-check_respTarget-29">
            <rule context="@resp">
              <assert role="warning" test="not(normalize-space(.) eq '')">@resp attribute should
                have content.</assert>
              <assert role="warning"
                 test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*[ancestor::mei:meiHead]/@xml:id">The value in @resp should correspond to the @xml:id attribute of an element within
                the metadata header.</assert>
            </rule>
          </pattern>
   <pattern id="schematron-constraint-wegaWorks-att.source-source-check_sourceTarget-30">
            <rule context="@source">
              <assert role="warning" test="not(normalize-space(.) eq '')">@source attribute
                should have content.</assert>
              <assert role="warning"
                 test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*[local-name() eq 'source' or local-name() eq 'manifestation']/@xml:id">Each value in @source should correspond to the @xml:id attribute of a source or
                manifestation element.</assert>
            </rule>
          </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-att.staff.log-def-check_defTarget_staff-31">
            <rule context="mei:staff/@def">
              <assert role="warning" test="not(normalize-space(.) eq '')">@def attribute should
                have content.</assert>
              <assert role="warning"
                 test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:staffDef/@xml:id">The value in @def should correspond to the @xml:id attribute of a staffDef
                element.</assert>
            </rule>
          </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-att.startEndId-endid-check_endidTarget-32">
            <rule context="@endid">
              <assert role="warning" test="not(normalize-space(.) eq '')">@endid attribute
                should have content.</assert>
              <assert role="warning"
                 test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id">The
                value in @endid should correspond to the @xml:id attribute of an
                element.</assert>
            </rule>
          </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-att.startId-startid-check_startidTarget-33">
            <rule context="@startid">
              <assert role="warning" test="not(normalize-space(.) eq '')">@startid attribute
                should have content.</assert>
              <assert role="warning"
                 test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id">The
                value in @startid should correspond to the @xml:id attribute of an
                element.</assert>
            </rule>
          </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-annot-Check_annot_data-34">
        <rule context="mei:annot[@data]">
          <assert test="ancestor::mei:notesStmt">The @data attribute may only occur on an
            annotation within the notesStmt element.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-clef-Clef_position_lines-35">
        <rule context="mei:clef[ancestor::mei:staffDef[@lines]]">
          <let name="thisstaff" value="ancestor::mei:staffDef/@n"/>
          <assert test="number(@line) &lt;= number(ancestor::mei:staffDef[@n=$thisstaff and @lines][1]/@lines)">The clef position must be less than or equal to the number of lines of an ancestor
            staff.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-clef-Clef_position_nolines-36">
        <rule context="mei:clef[ancestor::mei:staffDef[not(@lines)]]">
          <let name="thisstaff" value="ancestor::mei:staffDef/@n"/>
          <assert test="number(@line) &lt;= number(preceding::mei:staffDef[@n=$thisstaff and @lines][1]/@lines)">The clef position must be less than or equal to the number of lines of a preceding
            staff.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-contributor-check_contributor_role-37">
        <rule context="mei:contributor">
          <assert test="not(matches(normalize-space(lower-case(@role)),               '(arranger|author|composer|contributor|editor|funder|librettist|lyricist|sponsor)'))">The value of @role must not contain the name of another element available in this
            context.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-dir-dir_start-type_attributes_required-38">
        <rule context="mei:dir[not(ancestor::mei:syllable)]">
          <assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the
            attributes: startid, tstamp, tstamp.ges or tstamp.real.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-dynam-dynam_start-type_attributes_required-39">
        <rule context="mei:dynam">
          <assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real"> Must have one of
            the attributes: startid, tstamp, tstamp.ges or tstamp.real.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-dynam-dynam_end-type_attributes-40">
        <rule context="mei:dynam[@val2]">
          <assert test="@dur or @dur.ges or @endid or @tstamp2">When @val2 is present, either
            @dur, @dur.ges, @endid, or @tstamp2 must also be present.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-mei-Check_staff-41">
        <rule context="mei:*[@staff]">
          <assert test="every $i in tokenize(normalize-space(@staff), '\s+') satisfies $i=//mei:staffDef/@n">The values in @staff must correspond to @n attribute of a staffDef
            element.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-name-nameParts-42">
        <rule context="mei:name">
          <assert role="warning" test="not(mei:geogName or mei:persName or mei:corpName)">Recommended practice is to use name elements to capture sub-parts of a generic
            name.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-relation-FRBR_relation-43">
        
        <rule context="mei:relationList/mei:relation[parent::mei:work or parent::mei:expression or                        parent::mei:source or parent::mei:item]">
          <assert test="matches(@rel, 'hasAbridgement') or             matches(@rel, 'hasAbridgement') or             matches(@rel, 'isAbridgementOf') or             matches(@rel, 'hasAdaptation') or             matches(@rel, 'isAdaptationOf') or             matches(@rel, 'hasAlternate') or             matches(@rel, 'isAlternateOf') or             matches(@rel, 'hasArrangement') or             matches(@rel, 'isArrangementOf') or             matches(@rel, 'hasComplement') or             matches(@rel, 'isComplementOf') or             matches(@rel, 'hasEmbodiment') or             matches(@rel, 'isEmbodimentOf') or             matches(@rel, 'hasExemplar') or             matches(@rel, 'isExemplarOf') or             matches(@rel, 'hasImitation') or             matches(@rel, 'isImitationOf') or             matches(@rel, 'hasPart') or             matches(@rel, 'isPartOf') or             matches(@rel, 'hasRealization') or             matches(@rel, 'isRealizationOf') or             matches(@rel, 'hasReconfiguration') or             matches(@rel, 'isReconfigurationOf') or             matches(@rel, 'hasReproduction') or             matches(@rel, 'isReproductionOf') or             matches(@rel, 'hasRevision') or             matches(@rel, 'isRevisionOf') or             matches(@rel, 'hasSuccessor') or             matches(@rel, 'isSuccessorOf') or             matches(@rel, 'hasSummarization') or             matches(@rel, 'isSummarizationOf') or             matches(@rel, 'hasSupplement') or             matches(@rel, 'isSupplementOf') or             matches(@rel, 'hasTransformation') or             matches(@rel, 'isTransformationOf') or             matches(@rel, 'hasTranslation') or             matches(@rel, 'isTranslationOf')">Within work, expression, source, or item, the value of the rel attribute must match one
            of the following: hasAbridgement, isAbridgementOf, hasAdaptation, isAdaptationOf,
            hasAlternate, isAlternateOf, hasArrangement, isArrangementOf, hasComplement,
            isComplementOf, hasEmbodiment, isEmbodimentOf, hasExemplar, isExemplarOf, hasImitation,
            isImitationOf, hasPart, isPartOf, hasRealization, isRealizationOf, hasReconfiguration,
            isReconfigurationOf, hasReproduction, isReproductionOf, hasRevision, isRevisionOf,
            hasSuccessor, isSuccessorOf, hasSummarization, isSummarizationOf, hasSupplement,
            isSupplementOf, hasTransformation, isTransformationOf, hasTranslation,
            isTranslationOf</assert>
          <assert test="@target">Within work, expression, source or item, the target attribute
            must be present.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-respStmt-check_respStmt-44">
        <rule context="mei:respStmt[not(ancestor::mei:change)]">
          <assert test="(mei:resp and (mei:name or mei:corpName or mei:persName)) or              count(mei:*[@role]) = count(mei:*) and count(mei:*) &gt; 0"
                 role="warning">At least one element pair (a resp element and a name-like element) is
            recommended. Alternatively, each name-like element may have a @role
            attribute.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-rest-Check_restline-45">
        <rule context="mei:rest[@line]">
          <let name="thisstaff" value="ancestor::mei:staff/@n"/>
          <assert test="number(@line) &lt;= number(preceding::mei:staffDef[@n=$thisstaff and @lines][1]/@lines)">The value of @line must be less than or equal to the number of lines on the
            staff.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-section-Check_sectionexpansion-46">
        <rule context="mei:section[mei:expansion]">
          <assert test="descendant::mei:section|descendant::mei:ending|descendant::mei:rdg">A
            section containing an expansion element must have descendant section, ending, or rdg
            elements.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-staff-checkStaff_n-47">
        <rule context="mei:staff[@n]">
          <let name="thisstaff" value="@n"/>
          <assert test="preceding::mei:staffDef[@n=$thisstaff] or preceding::mei:staff[@n=$thisstaff]/mei:staffDef or mei:staffDef">There must be a preceding staffDef with a matching value of @n, a preceding staff with
            a matching @n value containing a staffDef, or a staffDef child element.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-staffDef-Check_staffDefn-48">
        <rule context="mei:staffDef[not(ancestor::mei:staff)]">
          <let name="thisstaff" value="@n"/>
          <assert test="@n">StaffDef must have an n attribute.</assert>
          <assert test="@lines or preceding::mei:staffDef[@n=$thisstaff and @lines]"> Either
            @lines must be present or a preceding staffDef with the same value for @n and @lines
            must exist.</assert>
          <assert test="count(mei:clef) + count(mei:clefGrp) &lt; 2">Only one clef or clefGrp is
            permitted.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-staffDef-Check_ancestor_staff-49">
        <rule context="mei:staffDef[ancestor::mei:staff and @n]">
          <let name="thisstaff" value="@n"/>
          <assert test="ancestor::mei:staff/@n eq $thisstaff">@n must have the same value as the
            current staff.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-staffDef-Check_ancestor_staff_lines-50">
        <rule context="mei:staffDef[ancestor::mei:staff and not(@n)]">
          <let name="thisstaff" value="ancestor::mei:staff/@n"/>
          <assert test="@lines or preceding::mei:staffDef[@n=$thisstaff and @lines]"> Either
            @lines must be present or a preceding staffDef with matching @n value and @lines must
            exist.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-staffDef-Check_clef_position_staffDef-51">
        <rule context="mei:staffDef[@clef.line and @lines]">
          <assert test="number(@clef.line) &lt;= number(@lines)">The clef position must be less
            than or equal to the number of lines on the staff.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-staffDef-Check_clef_position_staffDef_nolines-52">
        <rule context="mei:staffDef[@clef.line and not(@lines)]">
          <let name="thisstaff" value="@n"/>
          <let name="stafflines"
              value="preceding::mei:staffDef[@n=$thisstaff and @lines][1]/@lines"/>
          <assert test="number(@clef.line) &lt;= number($stafflines)">The clef position must be
            less than or equal to the number of lines on the staff.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-staffDef-Check_tab_strings_lines-53">
        <rule context="mei:staffDef[@tab.strings and @lines]">
          <let name="countTokens"
              value="count(tokenize(normalize-space(@tab.strings), '\s'))"/>
          <assert test="$countTokens = @lines">The tab.strings attribute must have the same
            number of values as there are staff lines.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-staffDef-Check_tab_strings_nolines-54">
        <rule context="mei:staffDef[@tab.strings and not(@lines)]">
          <let name="countTokens"
              value="count(tokenize(normalize-space(@tab.strings), '\s'))"/>
          <let name="thisstaff" value="@n"/>
          <assert test="$countTokens = preceding::mei:staffDef[@n=$thisstaff and @lines][1]/@lines">The
            tab.strings attribute must have the same number of values as there are staff
            lines.</assert>
        </rule>
      </pattern>
        <pattern>
          <rule context="mei:staffDef[@lines.color and @lines]">
            <let name="countTokens"
              value="count(tokenize(normalize-space(@lines.color), '\s'))"/>
            <assert test="$countTokens = 1 or $countTokens = @lines">The lines.color attribute
              must have either 1) a single value or 2) the same number of values as there are staff
              lines.</assert>
          </rule>
          <rule context="mei:staffDef[@lines.color and not(@lines)]">
            <let name="countTokens"
              value="count(tokenize(normalize-space(@lines.color), '\s'))"/>
            <let name="thisstaff" value="@n"/>
            <assert test="$countTokens = 1 or $countTokens = preceding::mei:staffDef[@n=$thisstaff and @lines][1]/@lines">The lines.color attribute must have either 1) a single value or 2) the same number of
              values as there are staff lines.</assert>
          </rule>
        </pattern>
      
        <pattern>
          <rule context="mei:staffDef[@ppq][ancestor::mei:scoreDef[@ppq]]">
            <let name="staffPPQ" value="@ppq"/>
            <let name="scorePPQ" value="ancestor::mei:scoreDef[@ppq][1]/@ppq"/>
            <assert test="($scorePPQ mod $staffPPQ) = 0">The value of ppq must be a factor of
              the value of ppq on an ancestor scoreDef.</assert>
          </rule>
        </pattern>
      
        <pattern>
          <rule context="mei:staffDef[@ppq][preceding::mei:scoreDef[@ppq]]">
            <let name="staffPPQ" value="@ppq"/>
            <let name="scorePPQ" value="preceding::mei:scoreDef[@ppq][1]/@ppq"/>
            <assert test="($scorePPQ mod $staffPPQ) = 0">The value of ppq must be a factor of
              the value of ppq on a preceding scoreDef.</assert>
          </rule>
        </pattern>
      <pattern id="isoschematron-constraint-wegaWorks-staffGrp-Check_staffGrp_unique_staff_n_values-58">
        <rule context="mei:staffGrp">
          <let name="countstaves" value="count(descendant::mei:staffDef)"/>
          <let name="countuniqstaves"
              value="count(distinct-values(descendant::mei:staffDef/@n))"/>
          <assert test="$countstaves eq $countuniqstaves">Each staffDef must have a unique value
            for the n attribute.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-tempo-tempo_in_header_disallow_most_attrs-59">
        <rule context="mei:tempo[not(ancestor::mei:score or ancestor::mei:part)]">
          <assert test="not(@*[name() != 'analog' and name() != 'class' and name() != 'label' and                name() != 'mm' and name() != 'mm.dots' and name() != 'translit' and                name() != 'type' and name() != 'mm.unit' and name() != 'n' and name() != 'xml:base' and                name() != 'xml:id' and name() != 'xml:lang'])">Only analog, class, label, mm, mm.dots, mm.unit, n, translit, type, xml:base, xml:id,
            and xml:lang attributes are allowed when tempo is not a descendant of a score or
            part.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-tempo-tempo_start-type_attributes_required-60">
        <rule context="mei:tempo[not(ancestor::mei:syllable) and not(ancestor::mei:work) and not(ancestor::mei:expression) and not(count(ancestor::mei:*) = 0)]">
          <assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the
            attributes: startid, tstamp, tstamp.ges or tstamp.real.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-term-Check_term_dataTarget-61">
        <rule context="mei:term[@data]">
          <assert test="ancestor::mei:classification">The @data attribute may only occur on a
            term which is a descendant of a classification element.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-componentList-checkComponentList-62">
        <rule context="mei:componentList">
          <assert test="every $i in ./child::mei:*[not(local-name()='head')] satisfies              $i/local-name() eq ./parent::mei:*/local-name()">Only child elements of the same name as the parent of the componentList are
            allowed.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-componentList-checkComponents-63">
        <rule context="mei:componentList[mei:*[@comptype]]">
          <assert role="warning"
                 test="count(mei:*[@comptype]) = count(mei:*[local-name() ne 'head'])">When any child
            element has a comptype attribute, it is recommended that comptype appear on all child
            elements.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-change-check_change-64">
        <rule context="mei:change">
          <assert test="@isodate or mei:date">The date of the change must be recorded in an
            isodate attribute or date element.</assert>
          <assert test="@resp or mei:respStmt[mei:name or mei:corpName or mei:persName]"
                 role="warning">It is recommended that the agent responsible for the change be recorded
            in a resp attribute or in a name, corpName, or persName element in the respStmt
            element.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-contents-checkContentsLabels-65">
        <rule context="mei:contents[mei:label]">
          <assert role="warning" test="count(mei:label) = count(mei:contentItem)">When labels
            are used, usually each content item has one.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-handList-checkHandListLabels-66">
        <rule context="mei:handList[mei:label]">
          <assert role="warning" test="count(mei:label) = count(mei:hand)">When labels are used,
            usually each hand has one.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-history-history_restriction-67">
        <rule context="mei:history[parent::mei:work or parent::mei:expression]">
          <assert test="not(mei:acquisition or mei:provenance)">The acquisition and provenance
            elements are not permitted in the work or expression context.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-incipCode-Check_incipCode_form_mimetype-68">
        <rule context="mei:incipCode">
          <assert test="@form or @mimetype">incipCode must have a form or mimetype
            attribute.</assert>
        </rule>
      </pattern>
   <pattern id="schematron-constraint-wegaWorks-meiHead-check_meiHead_type-69">
        <rule context="mei:meiHead[@type eq 'music']">
          <assert test="ancestor::mei:mei">The meiHead type attribute can have the value 'music'
            only when the document element is "mei".</assert>
        </rule>
        <rule context="mei:meiHead[@type eq 'corpus']">
          <assert test="ancestor::mei:meiCorpus">The meiHead type attribute can have the value
            'corpus' only when the document element is "meiCorpus".</assert>
        </rule>
        <rule context="mei:meiHead[@type eq 'independent']">
          <assert test="not(ancestor::mei:*)">The meiHead type attribute can have the value
            'independent' only when the document element is "meiHead".</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-source-id-check-70">
                                <rule context="mei:source">
                                    <assert test="@xml:id or ancestor::mei:source"> Am
                                        Wurzelelement muss eine XML-ID angegeben sein. </assert>
                                </rule>
                            </pattern>
   <pattern id="schematron-constraint-wegaWorks-source-check_source_target-71">
        <rule context="mei:source/@target">
          <assert role="warning" test="not(normalize-space(.) eq '')">@target attribute should
            have content.</assert>
          <assert role="warning"
                 test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*[local-name()              eq 'source' or local-name() eq 'manifestation']/@xml:id or matches($i, '^([a-z]+://|\.{1,2}/)')">Each value in @target should correspond to the @xml:id attribute of a source or
            manifestation element or be an external URI.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-termList-checkTermListLabels-72">
        <rule context="mei:termList[mei:label]">
          <assert role="warning" test="count(mei:label) = count(mei:term)">When labels are used,
            usually each term has one.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-work-id-check-73">
                                <rule context="mei:source">
                                    <assert test="@xml:id or ancestor::mei:source"> Am
                                        Wurzelelement muss eine XML-ID angegeben sein. </assert>
                                </rule>
                            </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-beam-When_not_copyof_beam_content-74">
        <rule context="mei:beam[not(@copyof)]">
          <assert test="count(descendant::*[local-name()='note' or local-name()='rest' or               local-name()='chord' or local-name()='space']) &gt; 1">A beam without a copyof attribute must have at least 2 note, rest, chord, or space
            descendants.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-beamSpan-beamspan_start-_and_end-type_attributes_required-75">
        <rule context="mei:beamSpan">
          <assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the
            attributes: startid, tstamp, tstamp.ges or tstamp.real.</assert>
          <assert test="@dur or @dur.ges or @endid or @tstamp2">Must have one of the attributes:
            dur, dur.ges, endid, or tstamp2.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-fermata-fermata_start-type_attributes_required-76">
        <rule context="mei:fermata">
          <assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the
            attributes: startid, tstamp, tstamp.ges or tstamp.real.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-hairpin-hairpin_start-_and_end-type_attributes_required-77">
        <rule context="mei:hairpin">
          <assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the
            attributes: startid, tstamp, tstamp.ges or tstamp.real.</assert>
          <assert test="@dur or @dur.ges or @endid or @tstamp2">Must have one of the attributes:
            dur, dur.ges, endid, or tstamp2.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-octave-octave_start-_and_end-type_attributes_required-78">
        <rule context="mei:octave">
          <assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the
            attributes: startid, tstamp, tstamp.ges or tstamp.real.</assert>
          <assert test="@dur or @dur.ges or @endid or @tstamp2">Must have one of the attributes:
            dur, dur.ges, endid, or tstamp2.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-slur-slur_start-_and_end-type_attributes_required-79">
        <rule context="mei:slur">
          <assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the
            attributes: startid, tstamp, tstamp.ges or tstamp.real.</assert>
          <assert test="@dur or @dur.ges or @endid or @tstamp2">Must have one of the attributes:
            dur, dur.ges, endid, or tstamp2.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-slur-slur_containing_curve-80">
        <rule context="mei:slur[mei:curve[@bezier or @bulge or @curvedir or @lform or @lwidth or              @ho or @startho or @endho or @to or @startto or @endto or @vo or @startvo or @endvo or              @x or @y or @x2 or @y2]]">
          <assert test="not(@bezier or @bulge or @curvedir or @lform or @lwidth or @ho or @startho or                @endho or @to or @startto or @endto or @vo or @startvo or @endvo or @x or @y or @x2 or @y2)"
                 role="warning">The visual attributes of the slur (@bezier, @bulge, @curvedir, @lform,
            @lwidth, @ho, @startho, @endho, @to, @startto, @endto, @vo, @startvo, @endvo, @x, @y,
            @x2, and @y2) will be overridden by visual attributes of the contained curve
            elements.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-tie-tie_start-_and_end-type_attributes_required-81">
        <rule context="mei:tie">
          <assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the
            attributes: startid, tstamp, tstamp.ges or tstamp.real.</assert>
          <assert test="@dur or @dur.ges or @endid or @tstamp2">Must have one of the attributes:
            dur, dur.ges, endid, or tstamp2.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-tie-tie_containing_curve-82">
        <rule context="mei:tie[mei:curve[@bezier or @bulge or @curvedir or @lform or @lwidth or              @ho or @startho or @endho or @to or @startto or @endto or @vo or @startvo or              @endvo or @x or @y or @x2 or @y2]]">
          <assert test="not(@bezier or @bulge or @curvedir or @lform or @lwidth or @ho or @startho or                @endho or @to or @startto or @endto or @vo or @startvo or @endvo or @x or @y or @x2 or @y2)"
                 role="warning">The visual attributes of the tie (@bezier, @bulge, @curvedir, @lform,
            @lwidth, @ho, @startho, @endho, @to, @startto, @endto, @vo, @startvo, @endvo, @x, @y,
            @x2, and @y2) will be overridden by visual attributes of the contained curve
            elements.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-tuplet-When_not_copyof_tuplet_content-83">
        <rule context="mei:tuplet[not(@copyof)]">
          <assert test="count(descendant::*[local-name()='note' or local-name()='rest' or               local-name()='chord']) &gt; 1">A tuplet without a copyof attribute must have at least 2 note, rest, or chord
            descendants.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-tupletSpan-tupletSpan_start-_and_end-type_attributes_required-84">
        <rule context="mei:tupletSpan">
          <assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the
            attributes: startid, tstamp, tstamp.ges or tstamp.real.</assert>
          <assert test="@dur or @dur.ges or @endid or @tstamp2">Must have one of the attributes:
            dur, dur.ges, endid, or tstamp2.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-trill-trill_start-type_attributes_required-85">
        <rule context="mei:trill">
          <assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the
            attributes: startid, tstamp, tstamp.ges or tstamp.real.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-turn-turn_start-type_attributes_required-86">
        <rule context="mei:turn">
          <assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the
            attributes: startid, tstamp, tstamp.ges or tstamp.real.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-list-list_type_constraint-87">
        <rule context="mei:list[contains(@type,'gloss')]">
          <assert test="count(mei:label) = count(mei:li)">In a list of type "gloss" all items
            must be immediately preceded by a label.</assert>
        </rule>
      </pattern>
   <pattern id="isoschematron-constraint-wegaWorks-cpMark-cpMark_start-_and_end-type_attributes_required-88">
        <rule context="mei:cpMark">
          <assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the
            attributes: startid, tstamp, tstamp.ges or tstamp.real</assert>
          <assert test="@dur or @dur.ges or @endid or @tstamp2">Must have one of the attributes:
            dur, dur.ges, endid, or tstamp2</assert>
        </rule>
      </pattern>
</schema>
